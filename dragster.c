#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     drive,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

long target = 0;
task P();
bool aligned = false;
float rate = 0;
float conv = -1000.0/0.415;
float error;
/*<-------DONT DELETE THIS ASTERISK PLEASE~!!!1!111111 OR THIS ONE ----->*/
//THIS IS THE BEST CODE THAT HAS BEEN WRITTEN
task main()
{
	bool isInMenu = true;
	float distance = 0;
	float encoder = 0;
	while(isInMenu){
		nxtDisplayCenteredTextLine(3, "Distance: %.1f", distance);
		if(nNxtButtonPressed == 1){
			distance+=0.5;
		}
		else if(nNxtButtonPressed == 2){
			distance-=0.5;
		}
		else if(nNxtButtonPressed == 3){
			nxtDisplayCenteredBigTextLine(3, "LAUNCH");
			isInMenu = false;
		}
		wait1Msec(250);
	}
	nMotorEncoder[drive] = 0;
	StartTask(P);
	target = distance * conv;
	while (!aligned)
		wait1Msec(100);
	StopTask(P);
}

task P()
{
	float prevErrorTime;
	float prevError;
	float errorTime;
	float kP = .05;
	aligned = false;
	time1[T1] = 0;
	while(true)
	{
		prevErrorTime = errorTime;
		prevError = error;
		errorTime = time1[T1];
		error = target - nMotorEncoder[drive];
		rate = (error - prevError)/(errorTime - prevErrorTime);
		if (abs(error) > 15 || abs(rate) > 10)
		{
			motor[drive] = kP * error;
			aligned = false;
		}
		else
			aligned = true;
		wait1Msec(100);
	}
}
